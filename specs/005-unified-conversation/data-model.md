# Data Model: Unified Conversation Experience

**Feature**: 005-unified-conversation  
**Date**: October 26, 2025  
**Status**: Complete

## Overview

This document defines the data models for the unified conversation experience. All models follow TypeScript strict typing requirements with readonly properties and discriminated union patterns for type safety.

## Core Entities

### 1. UnifiedConversationMessage

**Purpose**: Represents a single message in the unified conversation feed, supporting both transcription and chat message types.

**Type Definition**:
```typescript
/**
 * Unified message type using discriminated union pattern
 * Allows type-safe handling of both transcription and chat messages
 */
type UnifiedConversationMessage = 
  | TranscriptionConversationMessage 
  | ChatConversationMessage;

/**
 * Base message properties shared by all message types
 */
interface BaseConversationMessage {
  readonly id: string;              // UUID generated by crypto.randomUUID()
  readonly content: string;         // Message text content
  readonly timestamp: Date;         // When message was created/received
  readonly sender: MessageSender;   // 'user' or 'agent'
}

/**
 * Message sender type
 */
type MessageSender = 'user' | 'agent';

/**
 * Transcription message (from voice/audio)
 * Includes transcription-specific metadata
 */
interface TranscriptionConversationMessage extends BaseConversationMessage {
  readonly messageType: 'transcription';  // Discriminator field
  readonly confidence?: number;            // Transcription confidence (0-1)
  readonly isFinal: boolean;               // true = final, false = interim
  readonly language?: string;              // Language code (e.g., 'en-US')
}

/**
 * Chat message (from data channel text)
 * Simpler structure for text-only messages
 */
interface ChatConversationMessage extends BaseConversationMessage {
  readonly messageType: 'chat';           // Discriminator field
  readonly deliveryMethod: 'data-channel'; // Always data-channel for chat
}
```

**Validation Rules**:
- `id` must be a valid UUID string
- `content` must be non-empty string (min 1 character)
- `timestamp` must be a valid Date object
- `sender` must be either 'user' or 'agent'
- `confidence` (if present) must be between 0 and 1
- `isFinal` required for transcription messages
- `messageType` determines which additional fields are required

**Relationships**:
- Messages are ordered by `timestamp` in the conversation feed
- Messages with same sender + timestamp window (±500ms) may be deduplicated
- Interim transcriptions (`isFinal: false`) are replaced by final with matching criteria

**State Transitions**:
```
Interim Transcription (isFinal: false)
    ↓
Final Transcription Received
    ↓
Replace Interim with Final (same id or matching criteria)
    ↓
Persisted in ConversationFeed
```

### 2. ConversationFeedState

**Purpose**: Represents the complete state of the conversation feed, including all messages and metadata.

**Type Definition**:
```typescript
/**
 * Complete conversation feed state
 */
interface ConversationFeedState {
  readonly messages: readonly UnifiedConversationMessage[];  // All messages in feed
  readonly currentMode: ResponseMode;                         // 'voice' | 'chat'
  readonly sessionId: string;                                 // Unique session identifier
  readonly lastMessageAt: Date | null;                        // Timestamp of last message
  readonly messageCount: number;                              // Total message count
}

/**
 * Response mode type (from existing response-mode.model.ts)
 */
type ResponseMode = 'voice' | 'chat';
```

**Validation Rules**:
- `messages` must be sorted by `timestamp` in ascending order
- `sessionId` must be non-empty string (UUID recommended)
- `lastMessageAt` updated when new message added
- `messageCount` must equal `messages.length`

**Relationships**:
- Contains array of `UnifiedConversationMessage` entities
- Linked to `ResponseMode` from mode toggle system
- Persisted to sessionStorage keyed by `sessionId`

### 3. InterimTranscription

**Purpose**: Temporary state for in-progress transcription that hasn't been finalized yet.

**Type Definition**:
```typescript
/**
 * Interim transcription state (not yet in message feed)
 * Displayed separately with visual indication
 */
interface InterimTranscription {
  readonly speaker: MessageSender;  // 'user' or 'agent'
  readonly text: string;            // Current interim text
  readonly timestamp: Date;         // When transcription started
  readonly confidence?: number;     // Optional confidence score
}
```

**Validation Rules**:
- `text` may be empty string (transcription in progress)
- `speaker` must be 'user' or 'agent'
- Only one interim transcription active at a time (per speaker)

**State Transitions**:
```
Transcription Starts (interim)
    ↓
Text Updates (interim refinement)
    ↓
Final Transcription Received
    ↓
Convert to TranscriptionConversationMessage
    ↓
Clear InterimTranscription state
```

### 4. MessageMetadata

**Purpose**: Optional extended metadata for debugging and future features.

**Type Definition**:
```typescript
/**
 * Extended message metadata for debugging/analytics
 * Not required for MVP but structured for future use
 */
interface MessageMetadata {
  readonly messageSource: MessageSource;     // Where message originated
  readonly deliveryLatency?: number;         // Time from creation to display (ms)
  readonly transcriptionModel?: string;      // Which transcription model used
  readonly dataChannelId?: string;           // Data channel identifier
}

/**
 * Message source type
 */
type MessageSource = 
  | 'livekit-transcription'   // From LiveKit transcription track
  | 'livekit-data-channel'    // From LiveKit data channel
  | 'local-echo'              // Local user input echo
  | 'storage-restored';       // Restored from sessionStorage

```

**Validation Rules**:
- `deliveryLatency` must be non-negative number
- `messageSource` required for debugging
- Other fields optional

## Storage Schema

### SessionStorage Format

**Storage Key**: `melior-conversation-{sessionId}`

**Stored Value** (JSON):
```typescript
{
  "version": "1.0.0",
  "sessionId": "uuid-string",
  "currentMode": "voice" | "chat",
  "messages": [
    {
      "id": "uuid",
      "messageType": "transcription" | "chat",
      "content": "message text",
      "timestamp": "2025-10-26T12:34:56.789Z",  // ISO 8601 string
      "sender": "user" | "agent",
      // ... type-specific fields
    }
  ],
  "lastMessageAt": "2025-10-26T12:34:56.789Z",
  "messageCount": 42
}
```

**Serialization Rules**:
- Dates serialized as ISO 8601 strings
- Deserialization converts date strings back to Date objects
- Unknown fields ignored (forward compatibility)
- Invalid data triggers fallback to empty state

**Migration from Legacy Format**:
```typescript
// Legacy chat-storage format
{
  "messages": [
    {
      "id": "uuid",
      "content": "text",
      "timestamp": "ISO-string",
      "sender": "user" | "agent",
      "isLocal": false
    }
  ]
}

// Migration transform
legacyMessage → {
  ...legacyMessage,
  messageType: 'chat',
  deliveryMethod: 'data-channel'
}
```

## Factory Functions

**Purpose**: Create valid message instances with proper defaults and validation.

```typescript
/**
 * Create transcription message from LiveKit transcription event
 */
function createTranscriptionMessage(
  speaker: MessageSender,
  text: string,
  isFinal: boolean,
  confidence?: number,
  language?: string,
  timestamp: Date = new Date()
): TranscriptionConversationMessage {
  return {
    id: crypto.randomUUID(),
    messageType: 'transcription',
    content: text,
    timestamp,
    sender: speaker,
    confidence,
    isFinal,
    language
  };
}

/**
 * Create chat message from data channel event
 */
function createChatMessage(
  sender: MessageSender,
  content: string,
  timestamp: Date | number = new Date()
): ChatConversationMessage {
  return {
    id: crypto.randomUUID(),
    messageType: 'chat',
    content,
    timestamp: typeof timestamp === 'number' ? new Date(timestamp) : timestamp,
    sender,
    deliveryMethod: 'data-channel'
  };
}

/**
 * Create empty conversation feed state
 */
function createEmptyConversationFeed(
  sessionId: string,
  currentMode: ResponseMode = 'voice'
): ConversationFeedState {
  return {
    messages: [],
    currentMode,
    sessionId,
    lastMessageAt: null,
    messageCount: 0
  };
}

/**
 * Create interim transcription
 */
function createInterimTranscription(
  speaker: MessageSender,
  text: string,
  confidence?: number
): InterimTranscription {
  return {
    speaker,
    text,
    timestamp: new Date(),
    confidence
  };
}
```

## Type Guards

**Purpose**: Runtime type checking for discriminated unions.

```typescript
/**
 * Type guard for transcription messages
 */
function isTranscriptionMessage(
  message: UnifiedConversationMessage
): message is TranscriptionConversationMessage {
  return message.messageType === 'transcription';
}

/**
 * Type guard for chat messages
 */
function isChatMessage(
  message: UnifiedConversationMessage
): message is ChatConversationMessage {
  return message.messageType === 'chat';
}

/**
 * Type guard for valid message sender
 */
function isValidSender(value: unknown): value is MessageSender {
  return value === 'user' || value === 'agent';
}
```

## Usage Examples

### Creating Messages
```typescript
// User speaks (transcription)
const userMessage = createTranscriptionMessage(
  'user',
  'Hello, how are you?',
  true,  // isFinal
  0.95,  // confidence
  'en-US'
);

// Agent responds via chat
const agentMessage = createChatMessage(
  'agent',
  'I am doing well, thank you for asking!'
);

// Interim transcription
const interim = createInterimTranscription(
  'user',
  'Hello, how...',  // Incomplete
  0.82
);
```

### Type-Safe Message Handling
```typescript
function renderMessage(message: UnifiedConversationMessage): string {
  // TypeScript narrows type based on discriminator
  if (isTranscriptionMessage(message)) {
    return `[Transcription${message.isFinal ? '' : ' (interim)'}] ${message.content}`;
  } else {
    return `[Chat] ${message.content}`;
  }
}
```

### Sorting Messages
```typescript
function sortMessages(
  messages: UnifiedConversationMessage[]
): UnifiedConversationMessage[] {
  return [...messages].sort((a, b) => 
    a.timestamp.getTime() - b.timestamp.getTime()
  );
}
```

## Performance Considerations

### Memory Footprint
- Average message size: ~200 bytes (JSON)
- 100 messages: ~20 KB
- 1000 messages: ~200 KB
- sessionStorage limit: 5 MB (25,000 messages theoretical max)

### Serialization Cost
- JSON.stringify: O(n) where n = number of messages
- Debounce storage writes to max 1 write per 500ms
- Only serialize on message add/remove, not on reads

### Type Checking Cost
- Type guards are constant time O(1)
- Discriminated union checks are simple string comparisons
- No performance impact from TypeScript (types erased at runtime)

## Validation & Error Handling

### Required Field Validation
```typescript
function validateMessage(message: unknown): UnifiedConversationMessage {
  if (!message || typeof message !== 'object') {
    throw new Error('Message must be an object');
  }
  
  const msg = message as Partial<UnifiedConversationMessage>;
  
  if (!msg.id || !msg.content || !msg.timestamp || !msg.sender || !msg.messageType) {
    throw new Error('Missing required message fields');
  }
  
  if (!isValidSender(msg.sender)) {
    throw new Error(`Invalid sender: ${msg.sender}`);
  }
  
  // Type-specific validation
  if (msg.messageType === 'transcription' && msg.isFinal === undefined) {
    throw new Error('Transcription messages must have isFinal field');
  }
  
  return msg as UnifiedConversationMessage;
}
```

### Deserialization Error Handling
```typescript
function deserializeConversationFeed(json: string): ConversationFeedState | null {
  try {
    const data = JSON.parse(json);
    
    // Validate version
    if (data.version !== '1.0.0') {
      console.warn('Unknown conversation feed version:', data.version);
      return null;
    }
    
    // Convert date strings to Date objects
    const messages = data.messages.map((msg: any) => ({
      ...msg,
      timestamp: new Date(msg.timestamp)
    }));
    
    return {
      ...data,
      messages,
      lastMessageAt: data.lastMessageAt ? new Date(data.lastMessageAt) : null
    };
  } catch (error) {
    console.error('Failed to deserialize conversation feed:', error);
    return null;
  }
}
```

## Future Extensions

### Potential Additions (Out of Scope for v1)
- **Message reactions**: Add `reactions: Reaction[]` field
- **Message editing**: Add `editHistory: Edit[]` and `isEdited: boolean`
- **Threading**: Add `parentId?: string` and `threadId?: string`
- **Read receipts**: Add `readBy: string[]` timestamp map
- **Rich media**: Add `attachments: Attachment[]` for images/files

These extensions would maintain backward compatibility via version field in storage schema.
